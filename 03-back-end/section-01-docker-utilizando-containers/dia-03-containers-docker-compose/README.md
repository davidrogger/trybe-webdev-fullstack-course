anotaÃ§Ãµes pessoais...

# Docker Compose

Ã‰ a soluÃ§Ã£o para organizar o funcionamento e configuraÃ§Ã£o de todas essas partes que compÃµem um sistema, definimos em um arquivo de configuraÃ§Ã£o YAML todos os detalhes para executar nosso ambiente de desenvolvimento local, aproveitando as vantagens do Docker, sem nos preocupar em subir cada um dos contÃªineres que envolvem um app e seus respectivos parÃ¢metros especÃ­ficos.

# Networks - Redes no Docker

Ã‰ uma rede virtualizada que permite conectar contÃªineres a uma determinada rede ou a quantas redes Docker desejar. De modo que esses contÃªineres possam compartilhar informaÃ§Ãµes por meio dessa rede.
Por padrÃ£o, o Docker possui 3 redes que sÃ£o criadas junto a ele, sÃ£o elas: bridge, none e host. Cada uma delas tem caracterÃ­sticas especÃ­ficas quanto a conectividade para seus contÃªineres, elas podem ser consultadas pelo comando: `docker network ls`

## Bridge

Ao ser iniciado, todo contÃªiner Ã© associado a uma rede. Caso essa rede nÃ£o seja especificada explicitamente por nÃ³s, ele serÃ¡ associado Ã  rede Bridge.
Todos os contÃªineres associados a essa rede poderÃ£o se comunicar via protocolo TCP/IP e caso soubermos o IP do contÃªiner que queremos conectar, podemos enviar trÃ¡fego a ele. Entretando, os IPs de um contÃªiner sÃ£o gerados automaticamente, e nÃ£o Ã© efeitovo fazermos a conexao dessa forma, pois sempre que o contÃªiner for reiniciado, o IP poderÃ¡ mudar.

Uma outra possÃ­ovel maneira de fazermos a descoberta do IP automaticamente pelo nome, Ã© utilizando a opÃ§Ã£o `--link`. PorÃ©m a prÂ´orpia documentaÃ§Ã£o do Docker desencoraja seu uso e alerta que essa flag (`--link`) pode ser removida eventualmente.
Vamos ver um exemplo de como isso funciona, utilizando uma imagem busybox:

## Host

Ao associarmos um contÃªiner a essa rede, ela passa a compartilhar toda stack de rede do host, da mÃ¡quina que roda o ambiente Docker.

## None

Essa Ã© uma rede que nÃ£o possui nenhum driver associado. Dessa maneira, ao atribuir um contÃªiner a ela, o mesmo ficarÃ¡ isolado. Ela Ã© Ãºtil quando temos contÃªineres que utilizam arquivos para execuÃ§Ã£o de comandos ou para se comunicar, por exmeplo: um contÃªiner de backup ou que rode apenas um script localmente.

## Criando Nossa Rede

A forma mais recomendada de comunicarmos nossos contÃªineres Ã© criando nossa prÃ³pria rede. Por meio dela, conseguirmos referenciar um contÃªiner a partir de outro, utilizando seu nome.
```
docker network create -d bridge minha-rede
```

Para vincularmos nosso contÃªiner Ã  rede criada durante sua execuÃ§Ã£o:
```
docker container run \
    -itd \
    --network minha-rede \
     --name meu-container \
     busybox
```

Para listar as redes: `docker network ls`

Minha-rede seria a rede e o meu container o container
Para conectar a network ao container: `docker network connect minha-rede meu-container`
e para desconectar Ã© usado o mesmo comando alterando para: `disconnect`

## Volumes - Mapeando pastas para utilizaÃ§Ã£o em contÃªineres

Ã‰ usado para manter informaÃ§Ãµes salvas de um container.
usar um volume significa mapear uma pasta do nosso sistema hospedeiro, para o sistema convidado. Assim ela Ã© vinculada ao contÃªiner e essa pasta permanecerÃ¡ mesmo que esse contÃªiner seja removido.

Exemplo: Queremos desenvolver nossa pÃ¡gina HTML de forma que ela rode dentro do servidor http Apache, que nÃ£o estÃ¡ instalado em nossa mÃ¡quina. Ã€ medida que formos desenvolvendo nossa pÃ¡gina HTML, precisamos que o nosso ambiente de desenvolvimento permaneÃ§a no contÃªiner. Para isso, a primeira coisa que vamos fazer Ã© criar a seguinte pÃ¡gina HTML:
```
<!DOCTYPE html>
   <html>
      <head>
      <title>Docker Ã© muito bom!</title>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   </head>
   <body>
      <h1>Minha primeira pÃ¡gina rodando em Docker.</h1>
      <p>Estou comeÃ§ando minha primeira pÃ¡gina em HTML.</p>
   </body>
</html>
```

Salve o arquivo com o nome primeiro-teste.html em alguma pasta local de fÃ¡cil acesso.
* Aqui usaremos o caminho /home/trybe/meu-site.
Agora, vamos criar um contÃªiner que manterÃ¡ um volume vinculado a essa nossa pasta local, para que qualquer alteraÃ§Ã£o que fizermos em nosso HTML seja refletida no servidor http em nosso contÃªiner.
Para isso, vamos usar no comando run, o parÃ¢metro -v (de 'volume') da forma -v <PASTA-LOCAL>:<PASTA-CONTAINER>:
```
docker run -d --name site-trybe2 -p 8881:80 -v "/home/trybe/meu-site/:/usr/local/apache2/htdocs/" httpd:2.4
```

Vamos entender esse comando que acabamos de executar nos concentrando na flag -v:

. Essa flag cria um volume e Ã© seguida pelo endereÃ§o do diretÃ³rio em nossa mÃ¡quina /home/trybe/meu-site/ acompanhada do endereÃ§o no diretÃ³rio do servidor /usr/local/apache2/htdocs/, o qual serÃ¡ vinculado.
. Esse diretÃ³rio Ã© especÃ­fico para armazenar os arquivos que vÃ£o ser acessados no servidor http Apache, e pode ser diferente caso vocÃª opte por usar outro aplicativo.
. Qualquer modificaÃ§Ã£o que realizarmos no arquivo HTML em nossa mÃ¡quina local serÃ¡ refletido pelo contÃªiner no endereÃ§o da pasta do nosso servidor Apache.

Agora, acesse o site mantido pelo servidor Apache acessando o endereÃ§o http://localhost:8881/primeiro-teste.html no navegador e lÃ¡ estarÃ¡ o aquivo HTML que vocÃª acabou de criar.
Bora fazer um teste!? ğŸ’ª
Acesse novamente o arquivo primeiro-teste.html que acabamos de criar e edite-o da seguinte forma:
```
<!DOCTYPE html>
   <html>
      <head>
      <title>Docker Ã© muito bom!</title>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   </head>
   <body>
      <h1>Minha primeira pÃ¡gina rodando em Docker, que maravilha!</h1>
      <p>Estou comeÃ§ando minha primeira pÃ¡gina em HTML e estou muito feliz! #VQV</p>
   </body>
</html>
```

O que podemos concluir com isso?
1- Podemos criar um ambiente de desenvolvimento baseado apenas no uso de contÃªineres, o que facilita o trabalho dos times de desenvolvimento, jÃ¡ que o volume pode ser compartilhado entre o time e acessado via diferentes contÃªineres.
2- Tendo um volume na sua mÃ¡quina, vocÃª pode utilizar outros contÃªineres sem perder seus arquivos!
3- Quando usamos o volume, mesmo que o contÃªiner seja excluÃ­do, o volume serÃ¡ mantido. Isso quer dizer que tudo que colocarmos na pasta /usr/local/apache2/htdocs/, do contÃªiner, ficarÃ¡ preservado na pasta /home/trybe/meu-site em nossa mÃ¡quina.
Bora exemplificar essa afirmaÃ§Ã£o fazendo os seguinte comandos:
```
docker inspect site-trybe2 #que Ã© o nome que demos ao nosso container
```

Teremos uma saÃ­da com muitas informaÃ§Ãµes, mas o mais importante nesse momento Ã© o "Mounts" que nos mostra atravÃ©s da propriedade Source onde estÃ¡ o volume desse container em nosso Docker Host.
```
"Mounts": [
   {
      "Type": "bind",
      "Source": "/home/trybe/meu-site",
      "Destination": "/usr/local/apache2/htdocs",
      "Mode": "",
      "RW": true,
      "Propagation": "rprivate"
   }
]
```

Agora que confirmamos que temos um volume criado em nosso Docker Host, faremos a exclusÃ£o de nosso contÃªiner e verificaremos se junto com ele nossa pasta /home/trybe/meu-site tambÃ©m serÃ¡ excluÃ­da. Para isso, em posse do id do nosso contÃªiner primeiro precisamos parÃ¡-lo com o comando:
```
docker stop site-trybe2
```

Agora que paramos o nosso contÃªiner, vamos excluÃ­-lo com o comando:
```
docker rm site-trybe2
```

TambÃ©m Ã© possivel especificar os volumes da nossa imagem no nosso Dockerfile, usando o comando VOLUME.
```
VOLUME ["/data"]
```

Toda vez que criarmos um contÃªiner que mapeia um volume, ele alocarÃ¡ espaÃ§o para esse volume no seu sistema. Por tanto, Ã© sempre importante verificar seus volumes utilizando docker volume ls e remover aqueles que vocÃª nÃ£o utiliza, seja com o comando `docker volume rm <VOLUME NAME>`, seja com `docker volume prune`(esse comando remove todos os volumes que nÃ£o estÃ£o sendo utilizados por contÃªineres).

TambÃ©m Ã© possivel remover volumes automaticamente ao remover contÃªineres, utilizando o comando `docker container rm -v <CONTAINER ID || NAMES>`, onde o -v indica para o docker que o volume associado ao contÃªiner tambÃ©m deve ser removido.

## Docker Compose

Ã‰ uma ferramenta para definir e rodar aplicaÃ§Ãµes multi-containers Docker. Com ele, podemos automatizar a implantaÃ§Ã£o e gerenciamento dos contÃªineres.
Usamos para definir quais contÃªineres irÃ£o rodar e a partir de qual imagem deles serÃ£o criados.
Para isso Ã© usado um Ãºnico arquivo YAML com todos os detalhes e especificaÃ§Ãµes para subirmos os serviÃ§os de um ambiente em uma certa ordem prÃ©-determinada, sem a necessidade de subir cada um dos contÃªineres que compÃµe a aplicaÃ§Ã£o com seus parÃ¢metros especÃ­ficos no run.

Compose irÃ¡ trabalhar em conjunto com o Dockerfile.

# Instalando Docker Compose

Se vocÃª estiver utilizando Windows ou Mac, o Docker Compose jÃ¡ Ã© instalado junto com o Docker Desktop. Caso esteja utilizando alguma distro Linux, basta utilizar o seguinte comando para realizar a instalaÃ§Ã£o:
```
sudo curl -L "https://github.com/docker/compose/releases/download/1.25.5/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
```

Aplicando permissÃµes:
```
sudo chmod +x /usr/local/bin/docker-compose
```

Validando a instalaÃ§Ã£o:
```
docker-compose --version
```

[Guia oficial de instaÃ§Ã£o](https://docs.docker.com/compose/install/#install-compose)

## Compose File - Parte I

O arquivo Docker Compose Ã© onde conseguimos especificar todos os parÃ¢metros que antes rodÃ¡vamos unitariamente utilizando `docker container run`. TambÃ©m podemos criar os demais objetos utilizados pro eles, como redes e volumes.

Mepar todos os comandos e estruturÃ¡-los em um Ãºnico arquivo tem diversas vantagens. Uma delas, especialmente vantajosa quando estamos trabalhando com muitos contÃªiners, Ã© evitar a necessidade de digitar inÃºmeros parÃ¢metros em linha de comando com o run.
Toda configuraÃ§Ã£o do **Docker Compose** Ã© feita por meio de um arquivo YAML, o nome padrÃ£o usado Ã© `docker-compose.yaml`, porÃ©m pode ser usado qualquer outro nome.
```
version: "<VERSÃƒO-DO-COMPOSE>"
services: # DefiniÃ§Ã£o dos containers
  <MEU-CONTAINER-1>:
    image: <MINHA-IMAGEM:VERSÃƒO> # Exemplo carregando uma imagem jÃ¡ _buildada_
    # ... outras configuraÃ§Ãµes
  <MEU-CONTAINER-2>:
    build: <CAMINHO-DO-DOCKERFILE> # Exemplo gerando uma build a partir de um `Dockerfile`
    # ... outras configuraÃ§Ãµes
  <MEU-CONTAINER-N>:
    image: <MINHA-IMAGEM:VERSÃƒO>
    # ... outras configuraÃ§Ãµes
```

## Version

Todo arquivo docker-compose.yaml deve iniciar com a tag version. Para evitar que o docker-compse.yaml fique incompatÃ­vel com versÃµes mais recentes do compose.

[VersÃµes do Compose](https://docs.docker.com/compose/compose-file/compose-versioning/#versioning)

## Services

SÃ£o os "tipos" dos contÃªineres que iremos rodar. Podemos por exmeplo, escalar nossa API em 4 contÃªineres diferentes, de forma que teremos um service que Ã© a nossa API, porÃ©m com 4 contÃªineres em execuÃ§Ã£o. Dessa forma, ao escrevermos nosso arquivo, temos que pensar em services, pois Ã© assim que iremos defini-los.

Exemplo de como ficaria o arquivo Compose:
```
version: '3'
services:
  frontend::

  backend:

  database:
```

No exemplo Ã© dado um nome aos serviÃ§os, porÃ©m nÃ£o Ã© especificado o que deverÃ¡ ser executado, todo contÃªiner Ã© criado de uma image, precisamos especificar nos serviÃ§os:

1. image: para especificar uma imagem, seja local ou a ser baixada no Docker Hub;
2. build para apontar um diretÅ•oio com o Dockerfile a partir do qual o Compose irÃ¡ buildar a imagem.

Exemplo do arquivo docker-compse:
```
version: '3'
services:
  frontend:
    image: mjgargani/compose-example:frontend-trybe1.0
  backend:
    image: mjgargani/compose-example:backend-trybe1.0
  database:
    image: mjgargani/compose-example:database-trybe1.0
```

O arquivo irÃ¡ funcionar como se estivessem sendo executados trÃªs docker container run, um para cada serviÃ§o. Agora Ã© necessÃ¡rio definir os demais parÃ¢metros para os nossos contÃªineres.

## Restart

No Docker existem as polÃ­ticas de reinicializaÃ§Ã£o, que servem para gerenciar se nossos contÃªineres reiniciarÃ£o automaticamente quando o Docker for reiniciado ou quando ocorrer algum erro.

Comandos:
1. `no` - Este Ã© o valor padrÃ£o assumido pelo Docker e define que o container nÃ£o irÃ¡ restartar automaticamente;
2. `on-failure` - Define que o container serÃ¡ reiniciado caso ocorra alguma falha, apontando pelo `exit code` diferente de zero;
3. `always` - Espefica que sempre que o serviÃ§o parar, seja por uma falha ou porque ele finalizou sua execuÃ§Ã£o, ele irÃ¡ ser reiniciado;

Caso o contÃªiner seja interrompido manualmente, ele sÃ³ serÃ¡ reiniciado depois que o daemon do Docker for reiniciado ou que o prÃ³prio contÃªiner seja reiniciado manualmente. Esse Ã© um mecanismo pra evitar loops.

4. `unless-stopped` - Define que o contÃªiner sempre seja reiniciado, a menos que o Docker em si seja parado (manualmente ou nÃ£o). No caso de ser interrompido, ele nÃ£o reinicia nem se o daemon do Docker for reiniciado.

O daemon do Docker Ã© um processo contÃ­nuo e que roda em segundo plano, gerenciando os contÃªineres Docker em um host.

Ã‰ importante utilizarmos o parÃ¢metro em ambiente de produÃ§Ã£o, principalmente quando utilizamos o Docker Compose, conforme Ã© recomendado pelas especificaÃ§Ãµes da prÃ³pria documentaÃ§Ã£o.

Adicionando as configuraÃ§Ãµes o exemplo ficarÃ¡ assim:
```
version: '3'
services:
  frontend:
    image: mjgargani/compose-example:frontend-trybe1.0
    restart: always
  backend:
    image: mjgargani/compose-example:backend-trybe1.0
    restart: always
  database:
    image: mjgargani/compose-example:database-trybe1.0
    restart: always
```

## Ports

Uma configuraÃ§Ã£o importante Ã© a porta. No docker-compose temos o parÃ£metro ports que se comparta da mesma maneira que o -p do docker, no exmeplo vamos usar a porta 3000 para o frond-end e a porta 3001 para o back-end.
```
version: '3'
services:
  frontend:
    image: mjgargani/compose-example:frontend-trybe1.0
    restart: always
    ports:
      - 3000:3000
  backend:
    image: mjgargani/compose-example:backend-trybe1.0
    restart: always
    ports:
      - 3001:3001
  database:
    image: mjgargani/compose-example:database-trybe1.0
    restart: always
```

O primeiro parÃ¢metro (**3000**:3000) Ã© para a porta do host e o segundo (3000:**3000**) Ã© a porta exposta do contÃªiner.

## Environment

Com ele conseguimos configurar as variÃ¡veis de ambiente de nosso contÃªiner. Em uma situaÃ§Ã£o que precisamos passar para nosso back-end uma parte da URL onde o banco de dados irÃ¡ rodar, em uma variÃ¡vel chamada DB_HOST. Nosso exmeplo ficaria:
```
version: '3'
services:
  frontend:
    image: mjgargani/compose-example:frontend-trybe1.0
    restart: always
    ports:
      - 3000:3000
  backend:
    image: mjgargani/compose-example:backend-trybe1.0
    restart: always
    ports:
      - 3001:3001
    environment:
      - DB_HOST=database
  database:
    image: mjgargani/compose-example:database-trybe1.0
    restart: always
```

EstÃ¡ sendo passado a variÃ¡vel DB_HOST, que estÃ¡ em nosso host, para a variÃ¡vel "DB_HOST" do container, onde o back-end estÃ¡ esperando por ela.
Mesmo tendo a env configurada em seu ambiente, ela sÃ³ serÃ¡ passada ao contÃªiner se especificada aqui, da mesma maneira como fazemos com o parÃ¢metro -e ou --env no comando run.
Ã‰ possivel utilizarmos variaveis de ambiente. No caso de uma variÃ¡vel API_SECRET por se tratar de um dado sensÃ­vel, nÃ£o podemos colocÃ¡-lo em um arquivo a ser versionado como parte de nossa aplicaÃ§Ã£o, porÃ©m ainda temos que especificar ao compose qual variÃ¡vel irÃ¡ ser passada para qual contÃªiner.

No Contexto do Docker, secret Ã© um dado que nÃ£o deve ser transmitido por uma rede ou armazenada sem criptografia em um DOckerfile ou atÃ© mesmo no cÃ³digo fonte de sua aplicaÃ§Ã£o, como uma senha ou uma chave privada SSH. [DocumentaÃ§Ã£o sobre ambiente](https://docs.docker.com/compose/environment-variables/).

## Depends On

Garante a ordem de inicializaÃ§Ã£o e encerramento de services, com ele conseguimos estabelecer dependÃªncias entre os serviÃ§os.

Exemplo:
```
version: "3.8"
services:
  frontend:
    image: mjgargani/compose-example:frontend-trybe1.0
    restart: always
    ports:
      - 3000:3000
    depends_on:
      - "backend"
  backend:
    image: mjgargani/compose-example:backend-trybe1.0
    restart: always
    ports:
      - 3001:3001
    environment:
      - DB_HOST=database
    depends_on:
      - "database"
  database:
    image: mjgargani/compose-example:database-trybe1.0
    restart: always
```

Os services serÃ£o iniciados respeitando a ordem das dependÃªncias, database serÃ¡ iniciado antes do backend, que serÃ¡ iniciado antes do frontend.

# Gerenciando Services

## Up

Comando `docker-compose up`, o Compose irÃ¡ executar todos os contÃªineres especificados, baixando as imagens do repositÃ³rio ou montando localmente a partir do Dockerfile, de acordo com o que foi especificado no arquivo, nesse momento alÃ©m de executar os contÃªineres o compose irÃ¡ criar os demais objetos espeicificados, como redes e volumes.
Da mesma forma como rodamos os contÃªineres no modo daemon, podemos fazer no docker-compose up, utilizando o parÃ£metro -d

Caso tenha sido dado um nome diferente do padrÃ£o para o seu arquivo Compose, o parÃ¢metro -f pode ser utilizado. Lembra-se que ele pertence ao comando docker-compose, ele precisa ser passado logo apÃ³s o comando.

Exemplo:
```
docker-compose -f meu-arquivo-compose.yaml up
ou
docker-compose -f meu-arquivo-compose.yml stop
```
A sintaxe `docker-compose <COMMAND> -f` nÃ£o funcionarÃ¡.

Se o arquivo possuir o nome padrÃ£o(docker-compose.yaml), nÃ£o Ã© necessÃ¡rio passar a flag, apenas lembra-se de estar no mesmo diretÃ³rio do arquivo.

Pode-se usar o comando espeicificando o service.
Exemplo:
```
docker-compose up backend
```

O compose irÃ¡ iniciar o database, que foi definido no docker-compose como dependÃªncia do service backend, por meio do parÃ¢metrp depends_on.

Caso seja usado o parÃ¢metro build (que recebe o caminho do _Dockerfile) da aplicaÃ§Ã£o ao invÃ©s da imagem, o _Compose irÃ¡ construir a imagem se isso nÃ£o tiver sido feito anteriormente. Uma vez que a imagem seja 'construida' pelo compose, ele utilizarÃ¡ essa imagem jÃ¡ criada na prÃ³xima vez que executarmos o up, sem atualizÃ¡-la.
para forÃ§ar um novo build pode-se usar o tag --build especificando um service, caso nÃ£o seja especificado ele irÃ¡ tentar buildar todas as imagens possiveis novamente.
```
docker-compose up --build <SERVICE NAME>
```

Ã‰ comum usar o --build durante o desenvolvimento, para refletir as atualizaÃ§Ãµes no ambiente do Compose.

## Down

Com ele todos os containers irÃ£o ser parados e os objetos criados pelo up, como as redes.
```
docker-compose down
```

## Ps

Usado para listar os container ativos. SerÃ¡ listando somente os containers pertencentes ao arquivo do Compose.
```
docker-compose ps
```

## Stop

Com ele todos os containers irÃ£o ser parados, mas diferente do Down, ele nÃ£o irÃ£o remover as redes e outros objetos criados pelo Up.
Assim como o Up Ã© possivel determinar qual service serÃ¡ parado, respeitando as dependÃªncias.
Exemplo:
```
docker-compose stop backend
```
O backend serÃ¡ parado antes do database, ao executarmos esse comando.

## Start

Semelhante ao stop, com ele podemos iniciar os services parados referentes Ã  aquele arquivo compose. (pode-se usar o nome do server para iniciar tambÃ©m)
```
docker-compose start
```

## Logs

Com ele pode-se ver os logs dos services de maneira semelhante com os contÃªineres. Ã‰ possivel especificar um service para visualizar os logs de todos os seus contÃªineres ou ver todos os logs daquele ambiente, conforme arquivo do compose.
Pode-se tambÃ©m utilizar a flag -f ou --follow para acompanhar em tempo real as saÃ­das dos contÃªineres e o --tail para definir o nÃºmero de linhas para ser exebido a partir do final do log.
```
docker-compose logs -f --tail=100 <SERVICE NAME>
```

# Compose File - Parte II

## Volumes

Ã‰ possivel tambÃ©m usar volumes por meio do nosso arquivo compose.
Pode-se definir os volumes da mesma maneira que Ã© feito no comando docker container run, tanto como bind como da forma nomeada.

Usando uma forma mais extensa dele:

```
version: "3.8"
services:
  web:
    image: nginx:alpine
    volumes:
      - type: volume
        source: mydata
        target: /data
        volume:
          nocopy: true
      - type: bind
        source: ./static
        target: /opt/app/static

  db:
    image: postgres:latest
    volumes:
      - "/var/run/postgres/postgres.sock:/var/run/postgres/postgres.sock"
      - "dbdata:/var/lib/postgresql/data"

volumes:
  mydata:
  dbdata:
```

## Networks

Containers precisam estar na mesma rede para conseguir se comunicar utilizando o `name`.
Utilizando o Docker compose, isso jÃ¡ Ã© realizado de maneira padrÃ£o. Ao iniciar um novo arquivo, serÃ¡ criada uma rede padrÃ£o bridge para comunicaÃ§Ã£o de todos os serviÃ§oes espeicifcados, dessa forma conseguimos facilmente comunicar todos os services.

Se for apontado para o localhost:3000, o contÃªiner irÃ¡ acessar a prÃ³pria porta e nÃ£o irÃ¡ encontrar nada, pois o banco estÃ¡ em outro serviÃ§o. Por isso deve-se usar o nome do service.

Para isso, basta utilizar a opÃ§Ã£o networks em nossos serviÃ§os, definindo uma rede para um serviÃ§o especÃ­fico de forma semelhante ao volume, definimos as redes a serem criadas.

A sintaxe bÃ¡sica Ã© a seguinte:
```
version: "<VERSÃƒO-DO-COMPOSE>"
services:
  <MEU-CONTAINER-1>:
    image: <MINHA-IMAGEM:VERSÃƒO>
    networks:
      - <NETWORK-1>
    # ... outras configuraÃ§Ãµes
  <MEU-CONTAINER-2>:
    build: <CAMINHO-DO-DOCKERFILE>
    networks:
      - <NETWORK-1>
      - <NETWORK-1>
    # ... outras configuraÃ§Ãµes
  <MEU-CONTAINER-N>:
    image: <MINHA-IMAGEM:VERSÃƒO>
    # ... outras configuraÃ§Ãµes

networks:
  <NETWORK-1>:
```

Um exemplo, possuimos um ambiente com 3 services,um front-end e dois back-ends e mais um banco de dados. nessa arquteture, apenas os back-ends acessam o banco de dados e o front-end acessa os back-ends. Paracriarmosesse isolamento, nosso YAML ficaria semelhante ao exemplo abaixo:
```
version: '3'

services:
  frontend-a:
    build: ./frontend_a
    networks:
      - frontend

  backend-a:
    build: ./backend_a
    networks:
      - backend
      - frontend

  backend-b:
    build: ./backend_b
    networks:
      - backend
      - frontend

  db:
    image: mysql
    networks:
      - backend

networks:
  frontend:
  backend:
```

